% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{select}
\alias{select}
\title{Genetic Algorithm for Variable Selection in Generalized Linear Models}
\usage{
select(
  dat,
  x,
  y,
  glm_family,
  P,
  fit_func = "aic",
  num_iter,
  parent_sel = tournament,
  genetic_op = recombination,
  mut_prob = 0,
  elitism = TRUE
)
}
\arguments{
\item{dat}{Matrix of variables involved in regression.
nxp matrix of p variables (p-1 covariates and one response),
n observations per variable.}

\item{x}{Vector of column indices corresponding to covariates in `dat`.
`x` is used to subset `dat` to produce the design matrix for `glm.fit()`.}

\item{y}{Column index corresponding to response variable in `dat`.
`y` must be a unit length vector, used to subset `dat` to return
response variable for `glm.fit()`.}

\item{glm_family}{Regression family used in `glm.fit()`.
See `family()` for more information.}

\item{P}{Size of population.
`P` must be greater than or equal to 2.}

\item{fit_func}{Fitness function to be maximized by GA.
Default is AIC. If alternative is provided, it must be a function object
where the function takes a `glm` object and returns a score to be
maximized.}

\item{num_iter}{Number of iterations for GA algorithm.
Must be greater than 1.}

\item{parent_sel}{Parent selection function for GA.
If an alternative function is provided, it must take as input a vector
of scores and return a vector of indicies of length `2*P` corresponding
to sampled parents.}

\item{genetic_op}{Genetic operator function for GA.
Default is `recombination` function in package. If alternative function
is provided, it must take in as arguments a `2xP` matrix (each column consisting)
of a pair of indices for two coupled parents) as well as the population matrix
(`length(x)` by `P` matrix, each column consisting of booleans for each of the
`length(x)` variables in the original model). The function must then return
a new population matrix of same dimensions for the next generation.}

\item{mut_prob}{Mutation probability. Must be between 0 and 1.}

\item{elitism}{Whether or not to use elitism (guarantees that maximum fitness
is non-decreasing over iterations).}
}
\value{
Returns a named list with components `final_gen`, `scores`, `fittest`,
`fitness_by_gen` corresponding to the final population matrix, the vector of
scores for the final population, the column vector of `final_gen` corresponding
to the fittest individual, and a vector containing max fitness by generation (used
for plotting convergence).
}
\description{
This is an iterative algorithm for maximizing a fitness function evaluated on
fitted generalized linear models.
}
\examples{
# Try ordinary linear regression
data('mtcars')
fit <- lm(mpg ~ . -vs -am, data = mtcars)

# Generate input matrices
x <- model.matrix(fit)[,-1]
y <- model.response(fit$model)

# Select with rank selection
select(cbind(x,y), seq(ncol(x)), ncol(x) + 1, gaussian(link = 'identity'),
P = 100, num_iter = 100, mut_prob = .1, elitism = TRUE, parent_sel = rankselection)

# Try logistic regression
data('titanic')
fit <- glm(Survived ~ ., family = binomial(link = 'logit'), data = titanic)

# Generate input matrices
x <- model.matrix(fit)[,-1]
y <- model.response(fit$model)

# Select with default tournament selection
select(cbind(x,y), seq(ncol(x)), ncol(x) + 1, binomial(link = 'logit'),
P = 100, num_iter = 100, mut_prob = .1, elitism = TRUE)
}
